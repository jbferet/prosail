---
title: "5. Miscellaneous"
author: "Jean-Baptiste FÃ©ret, Florian de Boissieu"
date: "`r Sys.Date()`"
output:
  html_vignette:
    number_sections: true
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    toc_depth: 2
vignette: >
  \usepackage[utf8]{inputenc}
  %\VignetteIndexEntry{5. Miscellaneous}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval=FALSE
)
```

# Additional tips when running PROSAIL

### Adjust soil properties based on external source (e.g. image to process)

The `prosail` package does not include an exhaustive soil database. 
Therefore, it may be possible that soil optical properties corresponding to a 
scene in an optical image do not correspond to the default dry and wet soil 
reflectance defined as default soil properties.
In such case, users can define soil properties based on pixels corresponding 
bare soil and picked in the image, assuming that these exist.
The soil optical properties will then already have sensor spectral response. 
In this case, if users want to define custom soil properties, they need to apply 
sensor response function to all optical constants used in PROSAIL.

```{r simulate_LUT_Alternative}
# apply sensor characteristics to PROSPECT optical constants
wvl <- spec_prospect_fullrange$lambda
spec_sensor <- apply_sensor_characteristics(wvl,spec_prospect_fullrange,srf)
# apply sensor characteristics to atmospheric properties
spec_atm_sensor <- apply_sensor_characteristics(wvl,spec_atm,srf)
# apply sensor characteristics to soil properties
spec_soil_sensor <- apply_sensor_characteristics(wvl,spec_soil,srf)
```

This conversion can also be done using a unique function `prepare_sensor_simulation`: 

```{r conversion_SRF_OptCst}
# apply sensor characteristics to PROSPECT optical constants
properties_sensor <- prepare_sensor_simulation(spec_prospect_fullrange,spec_soil,spec_atm,srf)
spec_sensor <- properties_sensor$spec_prospect_sensor
spec_soil_sensor <- properties_sensor$spec_soil_sensor
spec_atm_sensor <- properties_sensor$spec_atm_sensor
```

... Then BRF, fAPAR and albedo can be computed based on these values:

```{r Apply_SRF_Reflectance}
# WL is a vector giving central wavelength for each band in nanometer
# fwhm is a vector giving fwhm for each band in nanometer
refl_sensor <- prosail(spec_sensor = spec_sensor,
                       chl = 40, car = 10, ewt = 0.01, ant = 0, lma = 0.01, 
                       n_struct = 1.5, type_lidf = 2, lidf_a = 50, lai = 4, q = 0.1, 
                       tts = 27, tto = 0, psi = 100, 
                       rsoil = spec_soil_sensor$max_refl)

# Computes BRF based on outputs from prosail and sun position
brf_sensor <- compute_brf(rdot = refl_sensor$rdot, 
                          rsot = refl_sensor$rsot, 
                          tts = tts,
                          spec_atm_sensor = spec_atm_sensor)

# Computes fAPAR based on outputs from PROSAIL and sun position
fapar_sensor <- compute_fapar(abs_dir = refl_sensor$abs_dir, 
                              abs_hem = refl_sensor$abs_hem, 
                              tts = tts, 
                              spec_atm_sensor = spec_atm_sensor)

# Computes albedo based on outputs from PROSAIL and sun position
albedo_sensor <- compute_albedo(rsdstar = refl_sensor$rsdstar, 
                                rddstar = refl_sensor$rddstar, 
                                tts = tts,
                                spec_atm_sensor = spec_atm_sensor)
```

### Use alternative implementation of machine learning algorithm for hybrid inversion

The default machine learning algorithm is support vector regression from the 
package `liquidSVM`. However, multiple users experienced difficulties installing 
this package. 
Therefore, an alternative SVR implementation based on the package `caret` is 
also implemented.

Set `method <- 'svmLinear'` or `method <- 'svmRadial'` when calling 
`train_prosail_inversion` to choose between the alternative implementations. 

Additional methods may be implemented with the support of users. 
